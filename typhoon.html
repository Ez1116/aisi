<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¢±é¢¨ç³»çµ±å»ºæ¨¡å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .workspace {
            display: flex;
            gap: 20px;
        }

        .toolbar {
            width: 250px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            height: fit-content;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }

        canvas {
            display: block;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
            position: absolute;
            top: 0;
            left: 0;
        }

        .tool-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        .tool-section:last-child {
            border-bottom: none;
        }

        .tool-section h3 {
            font-size: 14px;
            color: #555;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .tool-btn {
            padding: 8px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .tool-btn:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .tool-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 5px;
            border: 1px solid #ddd;
        }

        .layer-item input[type="checkbox"] {
            cursor: pointer;
        }

        .layer-item label {
            flex: 1;
            cursor: pointer;
            font-size: 13px;
        }

        .layer-item input[type="range"] {
            width: 60px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 8px;
        }

        .color-btn {
            width: 100%;
            height: 35px;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: #333;
        }

        .color-btn.active {
            border-color: #000;
            border-width: 3px;
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .control-group input[type="number"],
        .control-group input[type="text"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .action-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .action-btn.primary {
            background: #007bff;
            color: white;
        }

        .action-btn.primary:hover {
            background: #0056b3;
        }

        .action-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .action-btn.secondary:hover {
            background: #545b62;
        }

        .action-btn.danger {
            background: #dc3545;
            color: white;
        }

        .action-btn.danger:hover {
            background: #c82333;
        }

        .text-input-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }

        .text-input-panel.active {
            display: block;
        }

        .text-input-panel input {
            width: 300px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .text-input-panel button {
            padding: 8px 16px;
            margin-right: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.4;
        }

        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .symbol-btn {
            padding: 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .symbol-btn:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .symbol-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>é¢±é¢¨ç³»çµ±å»ºæ¨¡å·¥å…·</h1>
        
        <div class="workspace">
            <!-- å·¥å…·åˆ— -->
            <div class="toolbar">
                <!-- ç­†åˆ·è¨­å®š -->
                <div class="tool-section">
                    <h3>ç­†åˆ·è¨­å®š</h3>
                    <div class="control-group">
                        <label>ç­†åˆ·å¤§å°: <span id="brushSizeValue">5</span>px</label>
                        <input type="range" id="brushSize" min="1" max="50" value="5">
                    </div>
                    <div class="control-group">
                        <label>é€æ˜åº¦: <span id="opacityValue">100</span>%</label>
                        <input type="range" id="opacity" min="10" max="100" value="100">
                    </div>
                </div>

                <!-- é¡è‰²é¸æ“‡ -->
                <div class="tool-section">
                    <h3>é¡è‰²é¸æ“‡</h3>
                    <div class="color-palette">
                        <!-- é¢±é¢¨è·¯å¾‘ -->
                        <div class="color-btn active" style="background: #FF0000;" data-color="#FF0000" title="é¢±é¢¨è·¯å¾‘(ç´…)"></div>
                        <!-- æµ·æº« -->
                        <div class="color-btn" style="background: #0000FF;" data-color="#0000FF" title="å†·æµ·æº«(è—)"></div>
                        <div class="color-btn" style="background: #FF8800;" data-color="#FF8800" title="ç†±æµ·æº«(æ©™)"></div>
                        <!-- æ²³å· -->
                        <div class="color-btn" style="background: #20B2AA;" data-color="#20B2AA" title="æ²³å·(é’ç¶ )"></div>
                    </div>
                    <div class="info-text">
                        é¡è‰²åœ–ä¾‹:<br>
                        ç´…-é¢±é¢¨è·¯å¾‘ | è—/æ©™-æµ·æº«é«˜ä½<br>
                        é’ç¶ -æ²³å·
                    </div>
                </div>

                <!-- ç¹ªåœ–å·¥å…· -->
                <div class="tool-section">
                    <h3>ç¹ªåœ–å·¥å…·</h3>
                    <div class="tool-grid">
                        <button class="tool-btn active" data-tool="pen">âœï¸ è‡ªç”±ç¹ªè£½</button>
                        <button class="tool-btn" data-tool="line">ğŸ“ ç›´ç·š</button>
                        <button class="tool-btn" data-tool="arrow">â¡ï¸ ç®­é ­ç›´ç·š</button>
                        <button class="tool-btn" data-tool="curve">ã€°ï¸â¡ï¸ ç®­é ­æ›²ç·š</button>
                        <button class="tool-btn" data-tool="circle">â­• åœ“å½¢</button>
                        <button class="tool-btn" data-tool="rect">â¬œ çŸ©å½¢</button>
                        <button class="tool-btn" data-tool="text">T æ–‡å­—</button>
                    </div>
                </div>

                <!-- æ°£è±¡ç¬¦è™Ÿ -->
                <div class="tool-section">
                    <h3>æ°£è±¡ç¬¦è™Ÿ</h3>
                    <div class="symbol-grid">
                        <button class="symbol-btn" data-symbol="H">H</button>
                        <button class="symbol-btn" data-symbol="L">L</button>
                        <button class="symbol-btn" data-symbol="ğŸŒ€">ğŸŒ€</button>
                        <button class="symbol-btn" data-symbol="â›°ï¸">â›°ï¸</button>
                        <button class="symbol-btn" data-symbol="ğŸŒŠ">ğŸŒŠ</button>
                        <button class="symbol-btn" data-symbol="ğŸ’¨">ğŸ’¨</button>
                    </div>
                </div>

                <!-- å¿«é€Ÿæ“ä½œ -->
                <div class="tool-section">
                    <h3>å¿«é€Ÿæ“ä½œ</h3>
                    <button class="action-btn secondary" id="undo">â†¶ å¾©åŸ</button>
                    <button class="action-btn danger" id="deleteSelected" disabled>ğŸ—‘ï¸ åˆªé™¤é¸å–</button>
                    <button class="action-btn danger" id="clearCanvas">ğŸ—‘ï¸ æ¸…é™¤ç¹ªè£½</button>
                </div>

                <!-- åœ–å±¤ç®¡ç† -->
                <div class="tool-section">
                    <h3>åœ–å±¤ç®¡ç†</h3>
                    <div id="layerList">
                        <div class="layer-item">
                            <input type="checkbox" id="layer-base" checked>
                            <label for="layer-base">åº•åœ–</label>
                        </div>
                        <div class="layer-item">
                            <input type="checkbox" id="layer-drawing" checked>
                            <label for="layer-drawing">ç¹ªè£½å±¤</label>
                            <input type="range" id="drawingOpacity" min="0" max="100" value="100" title="é€æ˜åº¦">
                        </div>
                    </div>
                </div>

                <!-- æ“ä½œæŒ‰éˆ• -->
                <div class="tool-section">
                    <button class="action-btn primary" id="saveProject">ğŸ’¾ å„²å­˜å°ˆæ¡ˆ(JSON)</button>
                    <button class="action-btn primary" id="loadProject">ğŸ“‚ è¼‰å…¥å°ˆæ¡ˆ</button>
                    <button class="action-btn secondary" id="exportImage">ğŸ“· åŒ¯å‡ºåœ–ç‰‡(PNG)</button>
                </div>
            </div>

            <!-- ç•«å¸ƒå€åŸŸ -->
            <div class="canvas-container">
                <canvas id="baseCanvas"></canvas>
                <canvas id="drawingCanvas"></canvas>
                
                <!-- æ–‡å­—è¼¸å…¥é¢æ¿ -->
                <div class="text-input-panel" id="textInputPanel">
                    <input type="text" id="textInput" placeholder="è¼¸å…¥æ–‡å­—æ¨™è¨»...">
                    <button onclick="confirmText()">ç¢ºå®š</button>
                    <button onclick="cancelText()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" style="display: none;" accept=".json">

    <script>
        // ç•«å¸ƒè¨­å®š
        const baseCanvas = document.getElementById('baseCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const baseCtx = baseCanvas.getContext('2d');
        const drawingCtx = drawingCanvas.getContext('2d');

        let canvasWidth = 1000;
        let canvasHeight = 0;
        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#FF0000';
        let brushSize = 5;
        let opacity = 1;
        let startX, startY;
        let currentSymbol = null;
        let history = [];
        let currentPath = [];

        // ç‰©ä»¶å°å‘ç¹ªåœ–ç³»çµ±
        let drawingObjects = [];
        let selectedObject = null;
        let nextId = 1;

        // è®Šå½¢æ“ä½œç‹€æ…‹
        let dragMode = null;  // null, 'move', 'rotate', 'scale-nw', 'scale-ne', 'scale-sw', 'scale-se', 'scale-n', 'scale-s', 'scale-w', 'scale-e'
        let dragStartX = 0;
        let dragStartY = 0;
        let originalObjectState = null;

        // --- LocalStorage è‡ªå‹•å„²å­˜åŠŸèƒ½ ---
        const localStorageKey = "TyphoonDrawingData";
        const MAX_DRAWING_OBJECTS = 1000; // ç¹ªåœ–å°è±¡ä¸Šé™

        // è‡ªå‹•å„²å­˜ç‹€æ…‹åˆ° localStorage
        function autoSaveState() {
            const stateToSave = {
                currentSession: {
                    canvasWidth: canvasWidth,
                    canvasHeight: canvasHeight,
                    drawingObjects: [...drawingObjects],
                    nextId: nextId,
                    layers: {
                        baseVisible: document.getElementById('layer-base').checked,
                        drawingVisible: document.getElementById('layer-drawing').checked,
                        drawingOpacity: parseFloat(document.getElementById('drawingOpacity').value)
                    },
                    lastSaved: new Date().toISOString()
                },
                metadata: {
                    totalObjects: drawingObjects.length,
                    version: "1.0"
                }
            };

            // æª¢æŸ¥ç¹ªåœ–å°è±¡ç¸½æ•¸é™åˆ¶
            if (stateToSave.metadata.totalObjects > MAX_DRAWING_OBJECTS) {
                console.warn(`ç¹ªåœ–å°è±¡æ•¸é‡ (${stateToSave.metadata.totalObjects}) è¶…éä¸Šé™ (${MAX_DRAWING_OBJECTS})ï¼Œä¸é€²è¡Œè‡ªå‹•å„²å­˜`);
                return;
            }

            try {
                localStorage.setItem(localStorageKey, JSON.stringify(stateToSave));
                console.log(`âœ… è‡ªå‹•å„²å­˜æˆåŠŸï¼š${stateToSave.metadata.totalObjects} å€‹ç¹ªåœ–å°è±¡`);
            } catch (e) {
                console.error('è‡ªå‹•å„²å­˜å¤±æ•—:', e);
                handleStorageError(e);
            }
        }

        // è™•ç†å„²å­˜éŒ¯èª¤
        function handleStorageError(error) {
            if (error.name === 'QuotaExceededError') {
                alert('âš ï¸ ç€è¦½å™¨å„²å­˜ç©ºé–“ä¸è¶³\n\nåŸå› ï¼šç¹ªåœ–æ•¸æ“šéå¤š\n\nå»ºè­°ï¼š\n1. é»æ“Šã€ŒğŸ’¾ å„²å­˜å°ˆæ¡ˆ(JSON)ã€å°‡ä½œå“ä¿å­˜åˆ°æœ¬åœ°\n2. æ¸…é™¤éƒ¨åˆ†èˆŠçš„ç¹ªåœ–å…§å®¹\n3. ç¹¼çºŒæ­£å¸¸ä½¿ç”¨ï¼ˆå°‡ä¸æœƒè‡ªå‹•å„²å­˜ï¼‰');
                console.warn('localStorage ç©ºé–“ä¸è¶³ï¼Œå·²åœæ­¢è‡ªå‹•å„²å­˜');
            } else {
                console.error('å„²å­˜æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤:', error);
            }
        }

        // å¾ localStorage è¼‰å…¥ç‹€æ…‹
        function loadStateFromLocalStorage() {
            try {
                const storedData = localStorage.getItem(localStorageKey);

                if (!storedData) {
                    console.log('æ²’æœ‰å„²å­˜çš„è³‡æ–™ï¼Œä½¿ç”¨é è¨­ç‹€æ…‹');
                    return false;
                }

                const parsedData = JSON.parse(storedData);

                // æª¢æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
                if (!parsedData.currentSession) {
                    console.warn('èˆŠç‰ˆæœ¬æ•¸æ“šæ ¼å¼ï¼Œä½¿ç”¨é è¨­ç‹€æ…‹');
                    return false;
                }

                const session = parsedData.currentSession;

                // æ¢å¾©ç¹ªåœ–æ•¸æ“š
                if (session.canvasWidth) canvasWidth = session.canvasWidth;
                if (session.canvasHeight) canvasHeight = session.canvasHeight;
                if (session.drawingObjects) drawingObjects = [...session.drawingObjects];
                if (session.nextId) nextId = session.nextId;

                console.log(`âœ… æˆåŠŸè¼‰å…¥ç‹€æ…‹ï¼š${parsedData.metadata.totalObjects} å€‹ç¹ªåœ–å°è±¡`);
                return true;
            } catch (e) {
                console.error('è¼‰å…¥ç‹€æ…‹å¤±æ•—:', e);
                return false;
            }
        }

        // å¾ç‹€æ…‹æ›´æ–° UI
        function updateUIFromState() {
            try {
                const storedData = localStorage.getItem(localStorageKey);
                if (!storedData) return;

                const parsedData = JSON.parse(storedData);
                const session = parsedData.currentSession;

                // æ¢å¾©åœ–å±¤è¨­ç½®
                if (session.layers) {
                    const layerBase = document.getElementById('layer-base');
                    const layerDrawing = document.getElementById('layer-drawing');
                    const drawingOpacity = document.getElementById('drawingOpacity');

                    if (layerBase && session.layers.baseVisible !== undefined) {
                        layerBase.checked = session.layers.baseVisible;
                        baseCanvas.style.display = session.layers.baseVisible ? 'block' : 'none';
                    }

                    if (layerDrawing && session.layers.drawingVisible !== undefined) {
                        layerDrawing.checked = session.layers.drawingVisible;
                        drawingCanvas.style.display = session.layers.drawingVisible ? 'block' : 'none';
                    }

                    if (drawingOpacity && session.layers.drawingOpacity !== undefined) {
                        drawingOpacity.value = session.layers.drawingOpacity;
                        drawingCanvas.style.opacity = session.layers.drawingOpacity / 100;
                    }
                }

                // é‡ç¹ªåœ–è¡¨
                renderAllObjects();

                console.log('âœ… UI å·²å¾å„²å­˜ç‹€æ…‹æ¢å¾©');
            } catch (e) {
                console.error('æ›´æ–° UI å¤±æ•—:', e);
            }
        }

        // è¼‰å…¥åº•åœ–
        const baseImage = new Image();
        baseImage.src = 'map.png';
        baseImage.onload = function() {
            // å…ˆå˜—è©¦å¾ localStorage è¼‰å…¥ç‹€æ…‹
            const stateLoaded = loadStateFromLocalStorage();

            // å¦‚æœæ²’æœ‰è¼‰å…¥ç‹€æ…‹ï¼Œä½¿ç”¨åº•åœ–çš„åŸå§‹å°ºå¯¸
            if (!stateLoaded || !canvasWidth || !canvasHeight) {
                canvasWidth = baseImage.naturalWidth;
                canvasHeight = baseImage.naturalHeight;
            }

            baseCanvas.width = canvasWidth;
            baseCanvas.height = canvasHeight;
            drawingCanvas.width = canvasWidth;
            drawingCanvas.height = canvasHeight;

            baseCtx.drawImage(baseImage, 0, 0, canvasWidth, canvasHeight);
            saveHistory();

            // å¦‚æœæˆåŠŸè¼‰å…¥ç‹€æ…‹ï¼Œæ›´æ–° UI ä¸¦é‡ç¹ª
            if (stateLoaded) {
                updateUIFromState();
                console.log('âœ… æ‡‰ç”¨ç¨‹å¼å·²å¾ä¸Šæ¬¡ç‹€æ…‹æ¢å¾©');
            }
        };

        // å·¥å…·åˆ‡æ›
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentTool = this.dataset.tool;
            });
        });

        // é¡è‰²é¸æ“‡
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentColor = this.dataset.color;
            });
        });

        // ç¬¦è™ŸæŒ‰éˆ•
        document.querySelectorAll('.symbol-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const symbol = this.dataset.symbol;
                currentTool = 'symbol';
                currentSymbol = symbol;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.symbol-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // ç­†åˆ·è¨­å®š
        document.getElementById('brushSize').addEventListener('input', function() {
            brushSize = this.value;
            document.getElementById('brushSizeValue').textContent = this.value;
        });

        document.getElementById('opacity').addEventListener('input', function() {
            opacity = this.value / 100;
            document.getElementById('opacityValue').textContent = this.value;
        });

        // ç¹ªåœ–äº‹ä»¶
        let textToPlace = null;
        let pendingTextPosition = null;

        // åº§æ¨™è½‰æ›å‡½æ•¸ï¼ˆè™•ç†ç•«å¸ƒç¸®æ”¾ï¼‰
        function getCanvasCoordinates(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        function startDrawing(e) {
            const coords = getCanvasCoordinates(e);
            startX = coords.x;
            startY = coords.y;

            // å„ªå…ˆæª¢æŸ¥ï¼šæ˜¯å¦é»æ“Šåˆ°å·²é¸ä¸­ç‰©ä»¶çš„æ§åˆ¶é»
            if (selectedObject) {
                const bounds = getObjectBounds(selectedObject);
                if (bounds) {
                    const control = detectControlClick(coords.x, coords.y, bounds);
                    if (control) {
                        if (control === 'delete') {
                            // åˆªé™¤ç‰©ä»¶
                            const index = drawingObjects.findIndex(obj => obj.id === selectedObject.id);
                            if (index !== -1) {
                                drawingObjects.splice(index, 1);
                                selectedObject = null;
                                renderAllObjects();
                                updateDeleteButton();
                            }
                            return;
                        }
                        // é–‹å§‹æ‹–æ›³æ“ä½œï¼ˆç§»å‹•/ç¸®æ”¾/æ—‹è½‰ï¼‰
                        dragMode = control;
                        dragStartX = coords.x;
                        dragStartY = coords.y;
                        originalObjectState = cloneObject(selectedObject);
                        isDrawing = true;
                        return;
                    }
                }
            }

            // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ä»»ä½•ç‰©ä»¶ï¼ˆè‡ªå‹•é¸å–ï¼‰
            const clickedObject = findObjectAt(coords.x, coords.y);
            if (clickedObject) {
                selectedObject = clickedObject;
                renderAllObjects();
                updateDeleteButton();
                return;
            }

            // æœªé»æ“Šåˆ°ç‰©ä»¶ï¼Œå–æ¶ˆé¸å–ä¸¦åŸ·è¡Œç¹ªåœ–å·¥å…·
            selectedObject = null;
            updateDeleteButton();
            renderAllObjects();

            // é–‹å§‹ç¹ªåœ–æ“ä½œ
            isDrawing = true;
            currentPath = [{x: startX, y: startY}];

            if (currentTool === 'symbol') {
                // ç¬¦è™Ÿæ¨¡å¼ï¼šé–‹å§‹æ‹–æ›³èª¿æ•´å¤§å°ï¼ˆé¡ä¼¼åœ“å½¢ï¼‰
                return;
            }

            if (currentTool === 'text') {
                pendingTextPosition = {x: startX, y: startY};
                showTextInput();
                isDrawing = false;
                return;
            }

            if (currentTool === 'pen') {
                drawingCtx.beginPath();
                drawingCtx.moveTo(startX, startY);
            }
        }

        function draw(e) {
            if (!isDrawing) return;

            const coords = getCanvasCoordinates(e);
            const currentX = coords.x;
            const currentY = coords.y;

            // è™•ç†è®Šå½¢æ‹–æ›³
            if (dragMode && selectedObject && originalObjectState) {
                const dx = currentX - dragStartX;
                const dy = currentY - dragStartY;

                // æ¢å¾©åŸå§‹ç‹€æ…‹
                Object.assign(selectedObject, cloneObject(originalObjectState));

                const bounds = getObjectBounds(originalObjectState);
                if (!bounds) return;

                if (dragMode === 'move') {
                    moveObject(selectedObject, dx, dy);
                } else if (dragMode === 'rotate') {
                    const centerX = bounds.x + bounds.width / 2;
                    const centerY = bounds.y + bounds.height / 2;
                    const angle1 = Math.atan2(dragStartY - centerY, dragStartX - centerX);
                    const angle2 = Math.atan2(currentY - centerY, currentX - centerX);
                    const angle = angle2 - angle1;
                    rotateObject(selectedObject, angle, centerX, centerY);
                } else if (dragMode.startsWith('scale-')) {
                    // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                    const dir = dragMode.split('-')[1];
                    let scaleX = 1, scaleY = 1;
                    let originX = bounds.x, originY = bounds.y;

                    if (dir === 'se') {
                        originX = bounds.x;
                        originY = bounds.y;
                        scaleX = (bounds.width + dx) / bounds.width;
                        scaleY = (bounds.height + dy) / bounds.height;
                    } else if (dir === 'sw') {
                        originX = bounds.x + bounds.width;
                        originY = bounds.y;
                        scaleX = (bounds.width - dx) / bounds.width;
                        scaleY = (bounds.height + dy) / bounds.height;
                    } else if (dir === 'ne') {
                        originX = bounds.x;
                        originY = bounds.y + bounds.height;
                        scaleX = (bounds.width + dx) / bounds.width;
                        scaleY = (bounds.height - dy) / bounds.height;
                    } else if (dir === 'nw') {
                        originX = bounds.x + bounds.width;
                        originY = bounds.y + bounds.height;
                        scaleX = (bounds.width - dx) / bounds.width;
                        scaleY = (bounds.height - dy) / bounds.height;
                    } else if (dir === 'e') {
                        originX = bounds.x;
                        scaleX = (bounds.width + dx) / bounds.width;
                    } else if (dir === 'w') {
                        originX = bounds.x + bounds.width;
                        scaleX = (bounds.width - dx) / bounds.width;
                    } else if (dir === 's') {
                        originY = bounds.y;
                        scaleY = (bounds.height + dy) / bounds.height;
                    } else if (dir === 'n') {
                        originY = bounds.y + bounds.height;
                        scaleY = (bounds.height - dy) / bounds.height;
                    }

                    scaleObject(selectedObject, scaleX, scaleY, originX, originY);
                }

                renderAllObjects();
                return;
            }

            currentPath.push({x: currentX, y: currentY});

            drawingCtx.globalAlpha = opacity;
            drawingCtx.strokeStyle = currentColor;
            drawingCtx.fillStyle = currentColor;
            drawingCtx.lineWidth = brushSize;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';

            if (currentTool === 'pen') {
                drawingCtx.lineTo(currentX, currentY);
                drawingCtx.stroke();
            } else if (currentTool === 'line' || currentTool === 'arrow') {
                redrawCanvas();
                drawingCtx.globalAlpha = opacity;
                drawingCtx.strokeStyle = currentColor;
                drawingCtx.lineWidth = brushSize;
                
                drawingCtx.beginPath();
                drawingCtx.moveTo(startX, startY);
                drawingCtx.lineTo(currentX, currentY);
                drawingCtx.stroke();

                if (currentTool === 'arrow') {
                    drawArrowHead(startX, startY, currentX, currentY);
                }
            } else if (currentTool === 'curve') {
                if (currentPath.length < 3) return;
                redrawCanvas();
                drawingCtx.globalAlpha = opacity;
                drawingCtx.strokeStyle = currentColor;
                drawingCtx.lineWidth = brushSize;

                drawingCtx.beginPath();
                drawingCtx.moveTo(currentPath[0].x, currentPath[0].y);

                for (let i = 1; i < currentPath.length - 2; i++) {
                    const xc = (currentPath[i].x + currentPath[i + 1].x) / 2;
                    const yc = (currentPath[i].y + currentPath[i + 1].y) / 2;
                    drawingCtx.quadraticCurveTo(currentPath[i].x, currentPath[i].y, xc, yc);
                }

                drawingCtx.quadraticCurveTo(
                    currentPath[currentPath.length - 2].x,
                    currentPath[currentPath.length - 2].y,
                    currentPath[currentPath.length - 1].x,
                    currentPath[currentPath.length - 1].y
                );
                drawingCtx.stroke();

                // æ·»åŠ ç®­é ­ï¼šä½¿ç”¨è·é›¢è¶³å¤ é çš„é»è¨ˆç®—æ–¹å‘
                if (currentPath.length >= 2) {
                    const minDistance = brushSize * 4; // æœ€å°è·é›¢ç‚ºç­†åˆ·å¤§å°çš„4å€
                    const directionPoint = findDirectionPoint(currentPath, minDistance);
                    const lastPoint = currentPath[currentPath.length - 1];

                    if (directionPoint) {
                        drawArrowHead(
                            directionPoint.x,
                            directionPoint.y,
                            lastPoint.x,
                            lastPoint.y
                        );
                    }
                }
            } else if (currentTool === 'circle') {
                redrawCanvas();
                drawingCtx.globalAlpha = opacity;
                drawingCtx.strokeStyle = currentColor;
                drawingCtx.lineWidth = brushSize;
                
                const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                drawingCtx.beginPath();
                drawingCtx.arc(startX, startY, radius, 0, 2 * Math.PI);
                drawingCtx.stroke();
            } else if (currentTool === 'rect') {
                redrawCanvas();
                drawingCtx.globalAlpha = opacity;
                drawingCtx.strokeStyle = currentColor;
                drawingCtx.lineWidth = brushSize;

                drawingCtx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            } else if (currentTool === 'symbol') {
                redrawCanvas();
                drawingCtx.globalAlpha = opacity;
                drawingCtx.fillStyle = currentColor;

                // æ ¹æ“šæ‹–æ›³è·é›¢è¨ˆç®—ç¬¦è™Ÿå¤§å°
                const distance = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                const fontSize = Math.max(20, distance);

                // ç¹ªè£½ç¬¦è™Ÿé è¦½
                drawingCtx.font = `${fontSize}px Arial`;
                drawingCtx.fillText(currentSymbol, startX, startY);
            }
        }

        function stopDrawing(e) {
            if (isDrawing) {
                isDrawing = false;

                // çµæŸè®Šå½¢æ‹–æ›³
                if (dragMode) {
                    dragMode = null;
                    originalObjectState = null;
                    return;
                }

                // å‰µå»ºç¹ªåœ–ç‰©ä»¶
                let newObject = {
                    id: nextId++,
                    color: currentColor,
                    brushSize: brushSize,
                    opacity: opacity
                };

                if (currentTool === 'pen') {
                    if (currentPath.length > 0) {
                        newObject.type = 'pen';
                        newObject.path = [...currentPath];
                        drawingObjects.push(newObject);
                    }
                } else if (currentTool === 'line' && e) {
                    const coords = getCanvasCoordinates(e);
                    newObject.type = 'line';
                    newObject.x1 = startX;
                    newObject.y1 = startY;
                    newObject.x2 = coords.x;
                    newObject.y2 = coords.y;
                    drawingObjects.push(newObject);
                } else if (currentTool === 'arrow' && e) {
                    const coords = getCanvasCoordinates(e);
                    newObject.type = 'arrow';
                    newObject.x1 = startX;
                    newObject.y1 = startY;
                    newObject.x2 = coords.x;
                    newObject.y2 = coords.y;
                    drawingObjects.push(newObject);
                } else if (currentTool === 'circle' && e) {
                    const coords = getCanvasCoordinates(e);
                    const radius = Math.sqrt(Math.pow(coords.x - startX, 2) + Math.pow(coords.y - startY, 2));
                    if (radius > 0) {
                        newObject.type = 'circle';
                        newObject.cx = startX;
                        newObject.cy = startY;
                        newObject.radius = radius;
                        drawingObjects.push(newObject);
                    }
                } else if (currentTool === 'rect' && e) {
                    const coords = getCanvasCoordinates(e);
                    const width = coords.x - startX;
                    const height = coords.y - startY;
                    if (width !== 0 && height !== 0) {
                        newObject.type = 'rect';
                        newObject.x = startX;
                        newObject.y = startY;
                        newObject.width = width;
                        newObject.height = height;
                        drawingObjects.push(newObject);
                    }
                } else if (currentTool === 'curve') {
                    if (currentPath.length > 2) {
                        newObject.type = 'curve';
                        newObject.path = [...currentPath];
                        drawingObjects.push(newObject);
                    }
                } else if (currentTool === 'symbol' && e) {
                    const coords = getCanvasCoordinates(e);
                    const distance = Math.sqrt(Math.pow(coords.x - startX, 2) + Math.pow(coords.y - startY, 2));
                    if (distance > 5) {  // æœ€å°æ‹–æ›³è·é›¢
                        newObject.type = 'symbol';
                        newObject.symbol = currentSymbol;
                        newObject.x = startX;
                        newObject.y = startY;
                        newObject.fontSize = Math.max(20, distance);
                        newObject.rotation = 0;  // åˆå§‹æ—‹è½‰è§’åº¦
                        drawingObjects.push(newObject);
                    }
                }

                // é‡æ–°æ¸²æŸ“æ‰€æœ‰ç‰©ä»¶
                renderAllObjects();
                currentPath = [];

                // è‡ªå‹•å„²å­˜ç‹€æ…‹
                autoSaveState();
            }
        }

        // å¾è·¯å¾‘æœ«ç«¯æ‰¾åˆ°è·é›¢è‡³å°‘ minDistance çš„é»ï¼Œç”¨æ–¼è¨ˆç®—ç®­é ­æ–¹å‘
        function findDirectionPoint(path, minDistance) {
            if (path.length < 2) return null;

            const endPoint = path[path.length - 1];

            // å¾å¾Œå¾€å‰éæ­·ï¼Œæ‰¾åˆ°ç¬¬ä¸€å€‹è·é›¢è¶³å¤ é çš„é»
            for (let i = path.length - 2; i >= 0; i--) {
                const dx = endPoint.x - path[i].x;
                const dy = endPoint.y - path[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance >= minDistance) {
                    return path[i];
                }
            }

            // å¦‚æœæ²’æœ‰æ‰¾åˆ°è¶³å¤ é çš„é»ï¼Œè¿”å›æœ€é–‹å§‹çš„é»
            return path[0];
        }

        function drawArrowHead(fromX, fromY, toX, toY) {
            const headLength = brushSize * 3;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            drawingCtx.beginPath();
            drawingCtx.moveTo(toX, toY);
            drawingCtx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            drawingCtx.moveTo(toX, toY);
            drawingCtx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            drawingCtx.stroke();
        }

        function showTextInput() {
            const panel = document.getElementById('textInputPanel');
            const input = document.getElementById('textInput');
            
            if (textToPlace) {
                placeText(textToPlace);
                textToPlace = null;
            } else {
                panel.classList.add('active');
                input.value = '';
                input.focus();
            }
        }

        function confirmText() {
            const text = document.getElementById('textInput').value;
            if (text && pendingTextPosition) {
                placeText(text);
            }
            cancelText();
        }

        function cancelText() {
            document.getElementById('textInputPanel').classList.remove('active');
            pendingTextPosition = null;
        }

        function placeText(text) {
            if (!pendingTextPosition) return;

            // å‰µå»ºæ–‡å­—ç‰©ä»¶
            const textObject = {
                id: nextId++,
                type: 'text',
                text: text,
                x: pendingTextPosition.x,
                y: pendingTextPosition.y,
                color: currentColor,
                fontSize: brushSize * 4,
                opacity: opacity,
                brushSize: brushSize
            };

            drawingObjects.push(textObject);
            renderAllObjects();
            pendingTextPosition = null;
        }

        // é»æ“Šæª¢æ¸¬è¼”åŠ©å‡½æ•¸
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function pointToPathDistance(px, py, path) {
            let minDist = Infinity;
            for (let i = 1; i < path.length; i++) {
                const dist = pointToLineDistance(px, py, path[i-1].x, path[i-1].y, path[i].x, path[i].y);
                minDist = Math.min(minDist, dist);
            }
            return minDist;
        }

        function isPointInRect(px, py, x, y, width, height) {
            const minX = Math.min(x, x + width);
            const maxX = Math.max(x, x + width);
            const minY = Math.min(y, y + height);
            const maxY = Math.max(y, y + height);
            return px >= minX && px <= maxX && py >= minY && py <= maxY;
        }

        // å°‹æ‰¾é»æ“Šä½ç½®çš„ç‰©ä»¶ï¼ˆä¸æ”¹è®Šé¸å–ç‹€æ…‹ï¼‰
        function findObjectAt(x, y) {
            const threshold = 15; // é»æ“Šå®¹å·®

            // å¾å¾Œå¾€å‰æª¢æŸ¥ï¼ˆæœ€å¾Œç¹ªè£½çš„åœ¨æœ€ä¸Šå±¤ï¼‰
            for (let i = drawingObjects.length - 1; i >= 0; i--) {
                const obj = drawingObjects[i];
                let hit = false;

                if (obj.type === 'pen' || obj.type === 'curve') {
                    const dist = pointToPathDistance(x, y, obj.path);
                    hit = dist <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'line' || obj.type === 'arrow') {
                    const dist = pointToLineDistance(x, y, obj.x1, obj.y1, obj.x2, obj.y2);
                    hit = dist <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'circle') {
                    const distFromCenter = Math.sqrt(Math.pow(x - obj.cx, 2) + Math.pow(y - obj.cy, 2));
                    hit = Math.abs(distFromCenter - obj.radius) <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'rect') {
                    const inOuter = isPointInRect(x, y, obj.x - threshold, obj.y - threshold,
                        obj.width + 2*threshold, obj.height + 2*threshold);
                    const inInner = isPointInRect(x, y, obj.x + threshold, obj.y + threshold,
                        obj.width - 2*threshold, obj.height - 2*threshold);
                    hit = inOuter && !inInner;
                } else if (obj.type === 'text') {
                    const fontSize = obj.fontSize || 30;
                    const estimatedWidth = obj.text.length * fontSize * 0.6;
                    hit = isPointInRect(x, y, obj.x, obj.y - fontSize, estimatedWidth, fontSize);
                } else if (obj.type === 'symbol') {
                    const fontSize = obj.fontSize || 30;
                    const estimatedWidth = obj.symbol.length * fontSize * 0.8;
                    hit = isPointInRect(x, y, obj.x, obj.y - fontSize, estimatedWidth, fontSize);
                }

                if (hit) {
                    return obj;
                }
            }

            return null;
        }

        // é¸å–ç‰©ä»¶
        function selectObjectAt(x, y) {
            const threshold = 15; // é»æ“Šå®¹å·®
            selectedObject = null;

            // å¾å¾Œå¾€å‰æª¢æŸ¥ï¼ˆæœ€å¾Œç¹ªè£½çš„åœ¨æœ€ä¸Šå±¤ï¼‰
            for (let i = drawingObjects.length - 1; i >= 0; i--) {
                const obj = drawingObjects[i];
                let hit = false;

                if (obj.type === 'pen' || obj.type === 'curve') {
                    const dist = pointToPathDistance(x, y, obj.path);
                    hit = dist <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'line' || obj.type === 'arrow') {
                    const dist = pointToLineDistance(x, y, obj.x1, obj.y1, obj.x2, obj.y2);
                    hit = dist <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'circle') {
                    const distFromCenter = Math.sqrt(Math.pow(x - obj.cx, 2) + Math.pow(y - obj.cy, 2));
                    // æª¢æŸ¥æ˜¯å¦åœ¨åœ“çš„é‚Šç·£é™„è¿‘
                    hit = Math.abs(distFromCenter - obj.radius) <= threshold + obj.brushSize / 2;
                } else if (obj.type === 'rect') {
                    // æª¢æŸ¥æ˜¯å¦åœ¨çŸ©å½¢é‚Šç•Œé™„è¿‘
                    const inOuter = isPointInRect(x, y, obj.x - threshold, obj.y - threshold,
                        obj.width + 2*threshold, obj.height + 2*threshold);
                    const inInner = isPointInRect(x, y, obj.x + threshold, obj.y + threshold,
                        obj.width - 2*threshold, obj.height - 2*threshold);
                    hit = inOuter && !inInner;
                } else if (obj.type === 'text') {
                    const fontSize = obj.fontSize || 30;
                    const estimatedWidth = obj.text.length * fontSize * 0.6;
                    hit = isPointInRect(x, y, obj.x, obj.y - fontSize, estimatedWidth, fontSize);
                } else if (obj.type === 'symbol') {
                    const fontSize = obj.fontSize || 30;
                    const estimatedWidth = obj.symbol.length * fontSize * 0.8;
                    hit = isPointInRect(x, y, obj.x, obj.y - fontSize, estimatedWidth, fontSize);
                }

                if (hit) {
                    selectedObject = obj;
                    renderAllObjects();
                    updateDeleteButton();
                    return;
                }
            }

            // æ²’æœ‰é¸ä¸­ä»»ä½•ç‰©ä»¶
            renderAllObjects();
            updateDeleteButton();
        }

        function updateDeleteButton() {
            const deleteBtn = document.getElementById('deleteSelected');
            if (deleteBtn) {
                deleteBtn.disabled = !selectedObject;
            }
        }

        // ç¹ªè£½è®Šå½¢æ§åˆ¶é»
        function drawTransformControls(bounds) {
            const handleSize = 14;
            const padding = 15;

            // ç¹ªè£½æ§åˆ¶é»ï¼ˆç™½è‰²å¡«å……ï¼Œç¶ è‰²é‚Šæ¡†ï¼‰
            function drawHandle(x, y) {
                drawingCtx.fillStyle = '#FFFFFF';
                drawingCtx.strokeStyle = '#00FF00';
                drawingCtx.lineWidth = 3;
                drawingCtx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
                drawingCtx.strokeRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
            }

            // 8å€‹æ§åˆ¶é»ä½ç½®
            const handles = [
                {x: bounds.x - padding, y: bounds.y - padding, type: 'nw'},  // å·¦ä¸Š
                {x: bounds.x + bounds.width/2, y: bounds.y - padding, type: 'n'},  // ä¸Š
                {x: bounds.x + bounds.width + padding, y: bounds.y - padding, type: 'ne'},  // å³ä¸Š
                {x: bounds.x + bounds.width + padding, y: bounds.y + bounds.height/2, type: 'e'},  // å³
                {x: bounds.x + bounds.width + padding, y: bounds.y + bounds.height + padding, type: 'se'},  // å³ä¸‹
                {x: bounds.x + bounds.width/2, y: bounds.y + bounds.height + padding, type: 's'},  // ä¸‹
                {x: bounds.x - padding, y: bounds.y + bounds.height + padding, type: 'sw'},  // å·¦ä¸‹
                {x: bounds.x - padding, y: bounds.y + bounds.height/2, type: 'w'}  // å·¦
            ];

            handles.forEach(h => drawHandle(h.x, h.y));

            // ç¹ªè£½æ—‹è½‰æ§åˆ¶é»
            const rotX = bounds.x + bounds.width / 2;
            const rotY = bounds.y - padding - 30;

            // é€£æ¥ç·š
            drawingCtx.strokeStyle = '#00FF00';
            drawingCtx.lineWidth = 1;
            drawingCtx.beginPath();
            drawingCtx.moveTo(rotX, bounds.y - padding);
            drawingCtx.lineTo(rotX, rotY + 12);
            drawingCtx.stroke();

            // æ—‹è½‰æŠŠæ‰‹ï¼ˆåœ“å½¢ï¼‰
            drawingCtx.fillStyle = '#FFFFFF';
            drawingCtx.strokeStyle = '#00FF00';
            drawingCtx.lineWidth = 3;
            drawingCtx.beginPath();
            drawingCtx.arc(rotX, rotY, 12, 0, 2 * Math.PI);
            drawingCtx.fill();
            drawingCtx.stroke();

            // ç¹ªè£½åˆªé™¤æŒ‰éˆ•
            const delX = bounds.x + bounds.width + padding;
            const delY = bounds.y - padding;
            const delRadius = 15;

            // ç´…è‰²åœ“å½¢èƒŒæ™¯
            drawingCtx.fillStyle = '#FF0000';
            drawingCtx.beginPath();
            drawingCtx.arc(delX, delY, delRadius, 0, 2 * Math.PI);
            drawingCtx.fill();

            // ç™½è‰² X
            drawingCtx.strokeStyle = '#FFFFFF';
            drawingCtx.lineWidth = 3;
            drawingCtx.lineCap = 'round';
            const offset = 6;
            drawingCtx.beginPath();
            drawingCtx.moveTo(delX - offset, delY - offset);
            drawingCtx.lineTo(delX + offset, delY + offset);
            drawingCtx.moveTo(delX + offset, delY - offset);
            drawingCtx.lineTo(delX - offset, delY + offset);
            drawingCtx.stroke();
        }

        // æª¢æ¸¬é»æ“Šäº†å“ªå€‹æ§åˆ¶é»
        function detectControlClick(x, y, bounds) {
            const handleSize = 14;
            const padding = 15;

            // æª¢æ¸¬åˆªé™¤æŒ‰éˆ•
            const delX = bounds.x + bounds.width + padding;
            const delY = bounds.y - padding;
            if (Math.sqrt((x - delX)**2 + (y - delY)**2) <= 15) {
                return 'delete';
            }

            // æª¢æ¸¬æ—‹è½‰æ§åˆ¶é»
            const rotX = bounds.x + bounds.width / 2;
            const rotY = bounds.y - padding - 30;
            if (Math.sqrt((x - rotX)**2 + (y - rotY)**2) <= 12) {
                return 'rotate';
            }

            // æª¢æ¸¬8å€‹ç¸®æ”¾æ§åˆ¶é»
            const handles = [
                {x: bounds.x - padding, y: bounds.y - padding, type: 'scale-nw'},
                {x: bounds.x + bounds.width/2, y: bounds.y - padding, type: 'scale-n'},
                {x: bounds.x + bounds.width + padding, y: bounds.y - padding, type: 'scale-ne'},
                {x: bounds.x + bounds.width + padding, y: bounds.y + bounds.height/2, type: 'scale-e'},
                {x: bounds.x + bounds.width + padding, y: bounds.y + bounds.height + padding, type: 'scale-se'},
                {x: bounds.x + bounds.width/2, y: bounds.y + bounds.height + padding, type: 'scale-s'},
                {x: bounds.x - padding, y: bounds.y + bounds.height + padding, type: 'scale-sw'},
                {x: bounds.x - padding, y: bounds.y + bounds.height/2, type: 'scale-w'}
            ];

            for (let handle of handles) {
                if (Math.abs(x - handle.x) <= handleSize/2 && Math.abs(y - handle.y) <= handleSize/2) {
                    return handle.type;
                }
            }

            // æª¢æ¸¬æ˜¯å¦åœ¨ç‰©ä»¶ç¯„åœå…§ï¼ˆç”¨æ–¼ç§»å‹•ï¼‰
            if (x >= bounds.x - padding && x <= bounds.x + bounds.width + padding &&
                y >= bounds.y - padding && y <= bounds.y + bounds.height + padding) {
                return 'move';
            }

            return null;
        }

        // ç§»å‹•ç‰©ä»¶
        function moveObject(obj, dx, dy) {
            if (obj.type === 'pen' || obj.type === 'curve') {
                obj.path = obj.path.map(p => ({x: p.x + dx, y: p.y + dy}));
            } else if (obj.type === 'line' || obj.type === 'arrow') {
                obj.x1 += dx; obj.y1 += dy;
                obj.x2 += dx; obj.y2 += dy;
            } else if (obj.type === 'circle') {
                obj.cx += dx; obj.cy += dy;
            } else if (obj.type === 'rect') {
                obj.x += dx; obj.y += dy;
            } else if (obj.type === 'text') {
                obj.x += dx; obj.y += dy;
            } else if (obj.type === 'symbol') {
                obj.x += dx; obj.y += dy;
            }
        }

        // ç¸®æ”¾ç‰©ä»¶
        function scaleObject(obj, scaleX, scaleY, originX, originY) {
            if (obj.type === 'pen' || obj.type === 'curve') {
                obj.path = obj.path.map(p => ({
                    x: originX + (p.x - originX) * scaleX,
                    y: originY + (p.y - originY) * scaleY
                }));
            } else if (obj.type === 'line' || obj.type === 'arrow') {
                obj.x1 = originX + (obj.x1 - originX) * scaleX;
                obj.y1 = originY + (obj.y1 - originY) * scaleY;
                obj.x2 = originX + (obj.x2 - originX) * scaleX;
                obj.y2 = originY + (obj.y2 - originY) * scaleY;
            } else if (obj.type === 'circle') {
                obj.cx = originX + (obj.cx - originX) * scaleX;
                obj.cy = originY + (obj.cy - originY) * scaleY;
                obj.radius *= Math.max(scaleX, scaleY);
            } else if (obj.type === 'rect') {
                const newX = originX + (obj.x - originX) * scaleX;
                const newY = originY + (obj.y - originY) * scaleY;
                obj.width *= scaleX;
                obj.height *= scaleY;
                obj.x = newX;
                obj.y = newY;
            } else if (obj.type === 'text') {
                obj.x = originX + (obj.x - originX) * scaleX;
                obj.y = originY + (obj.y - originY) * scaleY;
                obj.fontSize *= Math.max(Math.abs(scaleX), Math.abs(scaleY));
            } else if (obj.type === 'symbol') {
                obj.x = originX + (obj.x - originX) * scaleX;
                obj.y = originY + (obj.y - originY) * scaleY;
                obj.fontSize *= Math.max(Math.abs(scaleX), Math.abs(scaleY));
            }
        }

        // æ—‹è½‰ç‰©ä»¶
        function rotateObject(obj, angle, centerX, centerY) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            function rotatePoint(x, y) {
                const dx = x - centerX;
                const dy = y - centerY;
                return {
                    x: centerX + dx * cos - dy * sin,
                    y: centerY + dx * sin + dy * cos
                };
            }

            if (obj.type === 'pen' || obj.type === 'curve') {
                obj.path = obj.path.map(p => rotatePoint(p.x, p.y));
            } else if (obj.type === 'line' || obj.type === 'arrow') {
                const p1 = rotatePoint(obj.x1, obj.y1);
                const p2 = rotatePoint(obj.x2, obj.y2);
                obj.x1 = p1.x; obj.y1 = p1.y;
                obj.x2 = p2.x; obj.y2 = p2.y;
            } else if (obj.type === 'circle') {
                const center = rotatePoint(obj.cx, obj.cy);
                obj.cx = center.x;
                obj.cy = center.y;
            } else if (obj.type === 'rect') {
                // å°æ–¼çŸ©å½¢ï¼Œè½‰æ›ç‚ºè·¯å¾‘é»å†æ—‹è½‰ï¼ˆç°¡åŒ–è™•ç†ï¼‰
                const corners = [
                    {x: obj.x, y: obj.y},
                    {x: obj.x + obj.width, y: obj.y},
                    {x: obj.x + obj.width, y: obj.y + obj.height},
                    {x: obj.x, y: obj.y + obj.height}
                ];
                const rotated = corners.map(c => rotatePoint(c.x, c.y));
                // æ›´æ–°ç‚ºæ–°çš„é‚Šç•Œ
                const xs = rotated.map(p => p.x);
                const ys = rotated.map(p => p.y);
                obj.x = Math.min(...xs);
                obj.y = Math.min(...ys);
                obj.width = Math.max(...xs) - obj.x;
                obj.height = Math.max(...ys) - obj.y;
            } else if (obj.type === 'text') {
                const pos = rotatePoint(obj.x, obj.y);
                obj.x = pos.x;
                obj.y = pos.y;
            } else if (obj.type === 'symbol') {
                // ç¬¦è™Ÿåªè‡ªè½‰ï¼Œä¸æ”¹è®Šä½ç½®
                obj.rotation = (obj.rotation || 0) + angle;
            }
        }

        // æ·±æ‹·è²ç‰©ä»¶ï¼ˆç”¨æ–¼å„²å­˜åŸå§‹ç‹€æ…‹ï¼‰
        function cloneObject(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        // æ¸²æŸ“æ‰€æœ‰ç‰©ä»¶
        function renderAllObjects() {
            // æ¸…ç©ºç¹ªåœ–å±¤
            drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // ç¹ªè£½æ‰€æœ‰ç‰©ä»¶
            drawingObjects.forEach(obj => {
                drawingCtx.globalAlpha = obj.opacity;
                drawingCtx.strokeStyle = obj.color;
                drawingCtx.fillStyle = obj.color;
                drawingCtx.lineWidth = obj.brushSize;
                drawingCtx.lineCap = 'round';
                drawingCtx.lineJoin = 'round';

                if (obj.type === 'pen') {
                    if (obj.path && obj.path.length > 1) {
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(obj.path[0].x, obj.path[0].y);
                        for (let i = 1; i < obj.path.length; i++) {
                            drawingCtx.lineTo(obj.path[i].x, obj.path[i].y);
                        }
                        drawingCtx.stroke();
                    }
                } else if (obj.type === 'line') {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(obj.x1, obj.y1);
                    drawingCtx.lineTo(obj.x2, obj.y2);
                    drawingCtx.stroke();
                } else if (obj.type === 'arrow') {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(obj.x1, obj.y1);
                    drawingCtx.lineTo(obj.x2, obj.y2);
                    drawingCtx.stroke();

                    const headLength = obj.brushSize * 3;
                    const angle = Math.atan2(obj.y2 - obj.y1, obj.x2 - obj.x1);
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(obj.x2, obj.y2);
                    drawingCtx.lineTo(
                        obj.x2 - headLength * Math.cos(angle - Math.PI / 6),
                        obj.y2 - headLength * Math.sin(angle - Math.PI / 6)
                    );
                    drawingCtx.moveTo(obj.x2, obj.y2);
                    drawingCtx.lineTo(
                        obj.x2 - headLength * Math.cos(angle + Math.PI / 6),
                        obj.y2 - headLength * Math.sin(angle + Math.PI / 6)
                    );
                    drawingCtx.stroke();
                } else if (obj.type === 'circle') {
                    drawingCtx.beginPath();
                    drawingCtx.arc(obj.cx, obj.cy, obj.radius, 0, 2 * Math.PI);
                    drawingCtx.stroke();
                } else if (obj.type === 'rect') {
                    drawingCtx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                } else if (obj.type === 'curve' && obj.path && obj.path.length > 2) {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(obj.path[0].x, obj.path[0].y);
                    for (let i = 1; i < obj.path.length; i++) {
                        const prev = obj.path[i - 1];
                        const curr = obj.path[i];
                        drawingCtx.quadraticCurveTo(prev.x, prev.y, curr.x, curr.y);
                    }
                    drawingCtx.stroke();

                    // æ·»åŠ ç®­é ­ï¼šä½¿ç”¨è·é›¢è¶³å¤ é çš„é»è¨ˆç®—æ–¹å‘
                    if (obj.path.length >= 2) {
                        const minDistance = obj.brushSize * 4; // æœ€å°è·é›¢ç‚ºç­†åˆ·å¤§å°çš„4å€
                        const directionPoint = findDirectionPoint(obj.path, minDistance);
                        const lastPoint = obj.path[obj.path.length - 1];

                        if (directionPoint) {
                            const headLength = obj.brushSize * 3;
                            const angle = Math.atan2(
                                lastPoint.y - directionPoint.y,
                                lastPoint.x - directionPoint.x
                            );

                            drawingCtx.beginPath();
                            drawingCtx.moveTo(lastPoint.x, lastPoint.y);
                            drawingCtx.lineTo(
                                lastPoint.x - headLength * Math.cos(angle - Math.PI / 6),
                                lastPoint.y - headLength * Math.sin(angle - Math.PI / 6)
                            );
                            drawingCtx.moveTo(lastPoint.x, lastPoint.y);
                            drawingCtx.lineTo(
                                lastPoint.x - headLength * Math.cos(angle + Math.PI / 6),
                                lastPoint.y - headLength * Math.sin(angle + Math.PI / 6)
                            );
                            drawingCtx.stroke();
                        }
                    }
                } else if (obj.type === 'text') {
                    drawingCtx.font = `${obj.fontSize || 30}px Arial`;
                    drawingCtx.fillText(obj.text, obj.x, obj.y);
                } else if (obj.type === 'symbol') {
                    const fontSize = obj.fontSize || 30;
                    const symbolLength = obj.symbol.length;

                    // è¨ˆç®—ç¬¦è™Ÿçš„è¦–è¦ºä¸­å¿ƒåç§»
                    const centerOffsetX = symbolLength * fontSize * 0.8 / 2;
                    const centerOffsetY = -fontSize / 2;

                    drawingCtx.save();
                    // ç§»å‹•åˆ°éŒ¨é»
                    drawingCtx.translate(obj.x, obj.y);
                    // åç§»åˆ°è¦–è¦ºä¸­å¿ƒ
                    drawingCtx.translate(centerOffsetX, centerOffsetY);
                    // åœç¹è¦–è¦ºä¸­å¿ƒæ—‹è½‰
                    drawingCtx.rotate(obj.rotation || 0);
                    // ç¹ªè£½æ™‚åå‘åç§»
                    drawingCtx.font = `${fontSize}px Arial`;
                    drawingCtx.fillText(obj.symbol, -centerOffsetX, -centerOffsetY);
                    drawingCtx.restore();
                }

                // å¦‚æœæ˜¯é¸ä¸­çš„ç‰©ä»¶ï¼Œç¹ªè£½é«˜äº®é‚Šæ¡†å’Œè®Šå½¢æ§åˆ¶é»
                if (selectedObject && obj.id === selectedObject.id) {
                    drawingCtx.globalAlpha = 1;
                    drawingCtx.strokeStyle = '#00FF00';
                    drawingCtx.lineWidth = 3;
                    drawingCtx.setLineDash([5, 5]);

                    const bounds = getObjectBounds(obj);
                    if (bounds) {
                        drawingCtx.strokeRect(bounds.x - 15, bounds.y - 15, bounds.width + 30, bounds.height + 30);
                        drawingCtx.setLineDash([]);
                        // ç¹ªè£½è®Šå½¢æ§åˆ¶é»
                        drawTransformControls(bounds);
                    }
                }
            });

            drawingCtx.globalAlpha = 1;
        }

        // å–å¾—ç‰©ä»¶é‚Šç•Œ
        function getObjectBounds(obj) {
            if (obj.type === 'pen' || obj.type === 'curve') {
                if (!obj.path || obj.path.length === 0) return null;
                const xs = obj.path.map(p => p.x);
                const ys = obj.path.map(p => p.y);
                return {
                    x: Math.min(...xs),
                    y: Math.min(...ys),
                    width: Math.max(...xs) - Math.min(...xs),
                    height: Math.max(...ys) - Math.min(...ys)
                };
            } else if (obj.type === 'line' || obj.type === 'arrow') {
                return {
                    x: Math.min(obj.x1, obj.x2),
                    y: Math.min(obj.y1, obj.y2),
                    width: Math.abs(obj.x2 - obj.x1),
                    height: Math.abs(obj.y2 - obj.y1)
                };
            } else if (obj.type === 'circle') {
                return {
                    x: obj.cx - obj.radius,
                    y: obj.cy - obj.radius,
                    width: obj.radius * 2,
                    height: obj.radius * 2
                };
            } else if (obj.type === 'rect') {
                return {
                    x: obj.x,
                    y: obj.y,
                    width: obj.width,
                    height: obj.height
                };
            } else if (obj.type === 'text') {
                return {
                    x: obj.x,
                    y: obj.y - (obj.fontSize || 30),
                    width: (obj.text.length * (obj.fontSize || 30) * 0.6),
                    height: obj.fontSize || 30
                };
            } else if (obj.type === 'symbol') {
                const fontSize = obj.fontSize || 30;
                // ç¬¦è™Ÿé€šå¸¸åªæœ‰1-2å€‹å­—å…ƒï¼Œè¨ˆç®—å¤§å°
                const symbolLength = obj.symbol.length;
                return {
                    x: obj.x,
                    y: obj.y - fontSize,
                    width: symbolLength * fontSize * 0.8,
                    height: fontSize
                };
            }
            return null;
        }

        // æ­·å²è¨˜éŒ„
        function saveHistory() {
            const imageData = drawingCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            history.push(imageData);
            if (history.length > 20) {
                history.shift();
            }
        }

        function redrawCanvas() {
            renderAllObjects();
        }

        // å¾©åŸåŠŸèƒ½ï¼ˆç§»é™¤æœ€å¾Œä¸€å€‹ç‰©ä»¶ï¼‰
        document.getElementById('undo').addEventListener('click', function() {
            if (drawingObjects.length > 0) {
                drawingObjects.pop();
                selectedObject = null;
                renderAllObjects();
                autoSaveState(); // è‡ªå‹•å„²å­˜
            }
        });

        // æ¸…é™¤ç•«å¸ƒ
        document.getElementById('clearCanvas').addEventListener('click', function() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰ç¹ªè£½å…§å®¹å—?')) {
                drawingObjects = [];
                selectedObject = null;
                renderAllObjects();
                autoSaveState(); // è‡ªå‹•å„²å­˜
            }
        });

        // åˆªé™¤é¸ä¸­çš„ç‰©ä»¶
        document.getElementById('deleteSelected').addEventListener('click', function() {
            if (selectedObject) {
                const index = drawingObjects.findIndex(obj => obj.id === selectedObject.id);
                if (index !== -1) {
                    drawingObjects.splice(index, 1);
                    selectedObject = null;
                    renderAllObjects();
                    updateDeleteButton();
                    autoSaveState(); // è‡ªå‹•å„²å­˜
                }
            }
        });

        // åœ–å±¤æ§åˆ¶
        document.getElementById('layer-base').addEventListener('change', function() {
            baseCanvas.style.display = this.checked ? 'block' : 'none';
            autoSaveState(); // è‡ªå‹•å„²å­˜
        });

        document.getElementById('layer-drawing').addEventListener('change', function() {
            drawingCanvas.style.display = this.checked ? 'block' : 'none';
            autoSaveState(); // è‡ªå‹•å„²å­˜
        });

        document.getElementById('drawingOpacity').addEventListener('input', function() {
            drawingCanvas.style.opacity = this.value / 100;
            autoSaveState(); // è‡ªå‹•å„²å­˜
        });

        // åŒ¯å‡ºåœ–ç‰‡
        document.getElementById('exportImage').addEventListener('click', function() {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvasWidth;
            exportCanvas.height = canvasHeight;
            const exportCtx = exportCanvas.getContext('2d');

            exportCtx.drawImage(baseCanvas, 0, 0);
            exportCtx.drawImage(drawingCanvas, 0, 0);

            exportCanvas.toBlob(function(blob) {
                if (blob) {
                    // ä¸»è¦æ–¹æ³•ï¼šä½¿ç”¨ Blob URL
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `typhoon_model_${new Date().getTime()}.png`;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // æˆåŠŸæç¤º
                    setTimeout(() => alert('âœ… åœ–ç‰‡å·²æˆåŠŸåŒ¯å‡ºï¼'), 100);
                } else {
                    // é™ç´šæ–¹æ¡ˆï¼šä½¿ç”¨ toDataURL
                    try {
                        const dataUrl = exportCanvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = `typhoon_model_${new Date().getTime()}.png`;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);

                        setTimeout(() => alert('âœ… åœ–ç‰‡å·²æˆåŠŸåŒ¯å‡ºï¼'), 100);
                    } catch (error) {
                        alert('âŒ åœ–ç‰‡åŒ¯å‡ºå¤±æ•—ï¼š' + error.message);
                    }
                }
            });
        });

        // å„²å­˜å°ˆæ¡ˆ
        document.getElementById('saveProject').addEventListener('click', function() {
            const projectData = {
                version: '2.0',
                timestamp: new Date().toISOString(),
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                drawingObjects: drawingObjects,
                nextId: nextId,
                settings: {
                    brushSize: brushSize,
                    opacity: opacity,
                    currentColor: currentColor,
                    currentTool: currentTool
                }
            };

            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `typhoon_project_${new Date().getTime()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // è¼‰å…¥å°ˆæ¡ˆ
        document.getElementById('loadProject').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const projectData = JSON.parse(event.target.result);

                    // æ”¯æ´èˆŠç‰ˆå’Œæ–°ç‰ˆå°ˆæ¡ˆæ ¼å¼
                    if (projectData.version === '2.0' && projectData.drawingObjects) {
                        // æ–°ç‰ˆç‰©ä»¶å¼å°ˆæ¡ˆ
                        drawingObjects = projectData.drawingObjects || [];
                        nextId = projectData.nextId || (drawingObjects.length > 0 ? Math.max(...drawingObjects.map(o => o.id)) + 1 : 1);
                        selectedObject = null;
                        renderAllObjects();
                    } else if (projectData.drawingData) {
                        // èˆŠç‰ˆåœ–ç‰‡å¼å°ˆæ¡ˆ
                        const img = new Image();
                        img.onload = function() {
                            drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                            drawingCtx.drawImage(img, 0, 0);
                        };
                        img.src = projectData.drawingData;
                    }

                    // è¼‰å…¥è¨­å®š
                    if (projectData.settings) {
                        brushSize = projectData.settings.brushSize || 5;
                        opacity = projectData.settings.opacity || 1;
                        currentColor = projectData.settings.currentColor || '#FF0000';
                        currentTool = projectData.settings.currentTool || 'pen';

                        document.getElementById('brushSize').value = brushSize;
                        document.getElementById('brushSizeValue').textContent = brushSize;
                        document.getElementById('opacity').value = opacity * 100;
                        document.getElementById('opacityValue').textContent = Math.round(opacity * 100);
                    }

                    // è‡ªå‹•å„²å­˜è¼‰å…¥çš„å°ˆæ¡ˆ
                    autoSaveState();

                    alert('å°ˆæ¡ˆè¼‰å…¥æˆåŠŸ!');
                } catch (error) {
                    alert('è¼‰å…¥å¤±æ•—: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        // æ–‡å­—è¼¸å…¥Enteréµ
        document.getElementById('textInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                confirmText();
            }
        });

        // éµç›¤å¿«æ·éµï¼šåˆªé™¤é¸ä¸­çš„ç‰©ä»¶
        document.addEventListener('keydown', function(e) {
            // æª¢æŸ¥æ˜¯å¦æŒ‰ä¸‹ Backspace æˆ– Delete
            if (e.key === 'Backspace' || e.key === 'Delete') {
                // æ’é™¤æ–‡å­—è¼¸å…¥é¢æ¿æ¿€æ´»ç‹€æ…‹
                const textInputPanel = document.getElementById('textInputPanel');
                const isTextInputActive = textInputPanel.classList.contains('active');

                // æ’é™¤æ­£åœ¨ä»»ä½•è¼¸å…¥æ¡†ä¸­è¼¸å…¥
                const isInInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';

                // åªåœ¨æœ‰é¸ä¸­ç‰©ä»¶ä¸”ä¸åœ¨è¼¸å…¥ç‹€æ…‹æ™‚åŸ·è¡Œåˆªé™¤
                if (selectedObject && !isTextInputActive && !isInInput) {
                    e.preventDefault(); // é˜²æ­¢ Backspace è§¸ç™¼ç€è¦½å™¨å¾Œé€€

                    // åŸ·è¡Œåˆªé™¤æ“ä½œ
                    const index = drawingObjects.findIndex(obj => obj.id === selectedObject.id);
                    if (index !== -1) {
                        drawingObjects.splice(index, 1);
                        selectedObject = null;
                        renderAllObjects();
                        updateDeleteButton();
                    }
                }
            }
        });
    </script>
</body>
</html>